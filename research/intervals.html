---
layout: stats
title: "Intervaller"
---

<h1>Intervaller</h1>
<p>I mange tilfælde kan konfidensintervaller udregnes ved hjælp af andre funktioner og kan derefter hentes fra deres output:</p>

<h2>KONFIDENSINTERVALLER</h2>
<h3>Kontinuerte data</h3>
<p>Konfidensintervallet for en kontinuert variabel kan udregnes fra en t-test, hvor funktionen <b>t.test</b>() bruges til at lave en one-sample t-test imod variables eget gennemsnit. Selve konfidensintervallet ekstraheres fra funktionen ved at sætte post-fixet <i>$conf.int[1:2]</i> efter funktionen - således at syntaksen bliver <b>t.test</b>(x, mu = <b><i>mean</i></b>(x))$conf.int[1:2]
</p>
<p class="rcode"> 
var1 <- round(rnorm(100, 10, 2),0) &emsp; &emsp; # Tilfældigt genereret variable<br>
mean(var1)<br>
t.test(var1, mu = mean(var1))$conf.int[1:2]</p>
<p class="routput">
[1] 10.03<br>
[1]  9.682921 10.377079
 </p>

<h3>Proportion</h3>
<p>For at udregne konfidensintervallet for en proportion kan man både bruge funktionerne <b>binom.test</b>() og <b>prop.test</b>(). Resultaterne vil ikke være helt ens, men vil oftest være meget til på hinanden, så det gør ikke den store forskel hvilken funktion man bruger. Til forskel fra Wald konfidensintervaller risikerer man ikke med nogle af metoderne at intervallet strækker sig under 0 eller over 1.</p>
<p>Hvis 75 ud af 100 personer (75%) er mænd kan proportion og konfidensinterval udregnes således:</p>
<b><i>Exact konfidensinterval</i></b>
<p><b>&emsp; binom.test</b>(x, n, conf.level = 0.95)$estimat <br>
<p><b>&emsp; binom.test</b>(x, n, conf.level = 0.95)$conf.int[1:2] </p>
<p class="rcode"> 
binom.test(75, 100, conf.level = 0.95)$estimat<br>
binom.test(75, 100, conf.level = 0.95)$conf.int[1:2]
</p>
<p class="routput"> 
probability of success <br>
  &emsp; &emsp; &emsp;  &emsp; &emsp;               0.75 <br>
[1] 0.6534475 0.8312203
</p>


<b><i>Wilson konfidensinterval</i></b>
<p><b>&emsp; prop.test</b>(x, n, conf.level = 0.95)$estimat <br>
<p><b>&emsp; prop.test</b>(x, n, conf.level = 0.95)$conf.int[1:2] </p>
<p class="rcode"> 
prop.test(75, 100, conf.level = 0.95)$estimat<br>
prop.test(75, 100, conf.level = 0.95)$conf.int[1:2]
</p>
<p class="routput"> 
   p <br>
0.75 <br>
[1] 0.6516159 0.8288245
</p>

<h3>Intervaller for variable med flere niveauer</h3>
<p>Hvis en variable har flere niveauer kan det blive lidt omstændigt at udregne konfidensintervaller for hver proportion for sig selv. 
 En måde at lette arbejdet lidt er at bruge pakken <code>{dplyr}</code> til først at udregne antal og procenter for hvert niveau og derefter til at udregne konfidensgrænserne 
 for hver linje. Med <code>{dplyr}</code> kan man lave sekvenser af funktioner, der forbindes fremadrettet med en pipe (<code>%&gt;%</code>); i udregningen nedenunder defineres 
 først datasættet <i>strokedata</i>, hvorefter funktionen <code>group_by</code> bruges til at definere at alle udregninger fremadrettet skal stratificeres med variablen <i>
 smoking</i>; dernæst bruges funktionen <code>summarise()</code> til at udregne antallet i hvert strate og funktionen <code>mutate()</code> til at lave to nye udregner af 
 totalen for alle strata og procent for hvert strata. Outputtet er en tabel i formattet <code>tibble</code>, som man via <code>dplyr</code> kan tilføje flere udregninger. 
 Hvis man vil lave udregninger for hver linje i tabellen kan man indsætte funktionen <code>rowwise()</code> og derefter funktionen <code>mutate()</code> hvor der kan indsættes 
 funktioner eller formler til at lave nye udregninger - i dette tilfælde <code><b>binom.test</b>()$conf.int[]</code>.
 </p>
<p class="rcode">
 library(dplyr)<br>
 d.smoke = strokedata %>% # filter(!is.na(smoking)) %>% <br>
  &emsp; group_by(smoking) %>% <br>
  &emsp; &emsp;  summarise(n = n()) %>% <br>
  &emsp; &emsp;  mutate(total = sum(n), percent = n/total*100)<br>
d.smoke = d.smoke %>% <br>
  &emsp; rowwise() %>% <br>
  &emsp;  mutate(ci.lwr = binom.test(n,total,conf.level = 0.95)$conf.int[1]*100,<br>
  &emsp;&emsp;         ci.upr = binom.test(n,total,conf.level = 0.95)$conf.int[2]*100)<br>
d.smoke</p>

<div class="routput"><table>
<tr><th style="text-align:left;">smoking </th><th>n </th><th> total</th><th>percent </th> <th>ci.lwr </th><th>ci.upr </th></tr>
<tr><th style="text-align:left;"> &lt;fctr&gt;</th><th> &lt;int&gt;</th><th>&lt;int&gt; </th><th>&lt;dbl&gt; </th><th> &lt;dbl&gt;</th><th>&lt;dbl> </th> </tr>
<tr><th style="text-align:left;">Current </th><th> 299</th><th> 1031	</th><th> 29.000970</th> <th>	26.245890 </th><th>31.876494 </th></tr>
<tr><th style="text-align:left;"> Never	</th><th> 384</th><th> 1031	</th><th> 37.245393</th><th>34.285835 </th><th>						40.278008 </th> </tr>
<tr><th> Previous</th><th>316 </th><th>1031	 </th><th>		30.649855 </th> <th>	27.845747 </th><th> 	33.564910</th></tr>
<tr><th style="text-align:left;">NA </th><th>32 </th><th> 1031	</th><th> 3.103783</th><th>			2.132472	 </th><th>4.353531 </th> </tr>
</table>
</div>
<h2>Forskel på Exact og Wilson konfidensintervaller</h2>
<p class="rcode">p.funk = function(z){<br>
&emsp; &emsp;  x = 1:z<br>
 &emsp; &emsp;  n = rep(z,z)<br>
&emsp; &emsp;   p = x/n<br>
&emsp; &emsp;   library(dplyr)<br>
&emsp; &emsp;   df = tibble(x,n,p)<br>
&emsp; &emsp;   df$e.lwr <- apply(X = df,MARGIN = 1,FUN = function(t){<br>
&emsp; &emsp;  &emsp; &emsp;  ci <- binom.test(x = t[1],n = t[2],conf.level = 0.95)$conf.int[1]})<br>
&emsp; &emsp;    df$e.upr <- apply(X = df,MARGIN = 1,FUN = function(t){<br>
&emsp; &emsp;  &emsp; &emsp;  ci <- binom.test(x = t[1],n = t[2],conf.level = 0.95)$conf.int[2]})<br>
&emsp; &emsp;    df$w.lwr <- apply(X = df,MARGIN = 1,FUN = function(t){<br>
&emsp; &emsp;  &emsp; &emsp;  ci <- prop.test(x = t[1],n = t[2],conf.level = 0.95)$conf.int[1]})<br>
&emsp; &emsp;    df$w.upr <- apply(X = df,MARGIN = 1,FUN = function(t){<br>
&emsp; &emsp;  &emsp; &emsp;  ci <- prop.test(x = t[1],n = t[2],conf.level = 0.95)$conf.int[2]})<br>
&emsp; &emsp;    library(ggplot2)<br>
&emsp; &emsp;    plot = ggplot(aes(), data = df) + geom_path(aes(x = p, y = p)) + geom_point(aes(x = p, y = p)) + <br>
&emsp; &emsp;      geom_line(aes(x = p, y = e.lwr), color = "red") + geom_point(aes(x = p, y = e.lwr), color = "red") +<br>
&emsp; &emsp;      geom_line(aes(x = p, y = e.upr), color = "red") + geom_point(aes(x = p, y = e.upr), color = "red") +<br>
&emsp; &emsp;      geom_line(aes(x = p, y = w.lwr), color = "blue") + geom_point(aes(x = p, y = w.lwr), color = "blue") +<br>
&emsp; &emsp;      geom_line(aes(x = p, y = w.upr), color = "blue") + geom_point(aes(x = p, y = w.upr), color = "blue") +<br>
&emsp; &emsp;      theme_minimal() + <br>
&emsp; &emsp;      annotate(geom = "label", x = 0.4, y = 0.75, label = "Exact", fill = "red", color = "white", fontface = "bold") +<br>
&emsp; &emsp;      annotate(geom = "label", x = 0.6, y = 0.25, label = "Wilson", fill = "blue", color = "white", fontface = "bold")<br>
 <br> 
&emsp; &emsp;    return( plot )<br>
}<br>
p.funk(30)</p>

<div class="illustration">
 <img src="/research/images/propci.png">
 <p>Konfidensgrænser for henholdsvis Exact og Wilson konfidensintervaller for proportioner ved populationsstørrelserne 10, 20 og 40. 
  Konfidensgrænserne ved begge metoder ligger tæt på hinanden og ved n=40 er de næsten ens.</p>
</div>

<h2>REFERENCE INTERVAL</h2>
<p>Referenceintervaller for normalværdier kan udregnes på baggrund af en variabel med funktionen <b>qnorm</b>(c( 0.5&plusmn;( (1-&alpha;<sub>z</sub>)/2) ), <b><i>mean</i></b>(x), <b><i>sd</i></b>(x)), hvor x er variablen<p>
<p>Eksempel med 95% (&alpha; = 0.05) referenceinterval for variabel 1 (0.5&plusmn;( (1-0.05)/2) ) = 0.025; 0.975 )</p>
<p class="rcode">
qnorm(c(0.025, 0.975), mean(var1), sd(var1))
 </p>
<p class="routput">[1]  6.601633 13.458367 </p>
